<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas</title>
    <style>
        /* æ²‰æµ¸èƒŒæ™¯ */
        body, html { margin: 0; padding: 0; overflow: hidden; background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%); height: 100%; font-family: "Microsoft YaHei", sans-serif; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        #start-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.85);
            width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s;
            position: absolute; top: 0; left: 0; z-index: 200;
            backdrop-filter: blur(5px);
        }

        .btn-play {
            padding: 18px 65px; font-size: 1.3rem; color: #fff;
            background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 114, 255, 0.6);
            font-weight: bold; letter-spacing: 4px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 50% { transform: scale(1.05); box-shadow: 0 0 50px rgba(0, 114, 255, 0.9); } }

        .hint { color: #ccc; margin-top: 25px; font-size: 13px; letter-spacing: 1px; text-shadow: 0 0 5px #000; }

        #subtitle {
            position: absolute; bottom: 12%; width: 100%; text-align: center;
            color: #fff; font-size: 1.3rem; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
            opacity: 0; transition: opacity 1s;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="start-screen">
        <button id="playBtn" class="btn-play">ğŸ åœ£è¯å¿«ä¹</button>
        <!-- <div class="hint">å®Œç¾æ— ç¼ | ç‘é›ªé™ä¸´ | ç»å…¸ä¹ç« </div> -->
    </div>
    <div id="subtitle"></div>
</div>

<canvas id="canvas"></canvas>

<!-- å·²æ›´æ¢ä¸ºç»å…¸çš„ We Wish You A Merry Christmas -->
<audio id="bgm" loop>
    <source src="https://music.163.com/song/media/outer/url?id=1899436041.mp3" type="audio/mpeg">
</audio>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const subtitle = document.getElementById('subtitle');
    const startScreen = document.getElementById('start-screen');
    const playBtn = document.getElementById('playBtn');
    
    let width, height;
    let renderList = []; 
    let skyStars = [];   
    let snowList = [];   
    let fireworks = [];
    let isPlaying = false;
    let startTime = 0;
    
    const CAMERA_Z = -1200; 
    
    // äº¤äº’
    let angleY = 0;
    let autoRotateSpeed = 0.0015;
    let isDragging = false;
    let lastX = 0;
    let velocity = 0;

    const WISH_WORDS = [
        { text: "è€å©†", y: -600, color: "#FF3366", size: 50 },
        { text: "åœ£è¯å¿«ä¹", y: -400, color: "#FFD700", size: 40 },
        { text: "å¹³å®‰å–œä¹", y: -200, color: "#00FFFF", size: 35 },
        { text: "æ°¸è¿œçˆ±ä½ ", y: 0, color: "#FF69B4", size: 40 }
    ];

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- äº¤äº’ ---
    function onStart(x) { isDragging = true; lastX = x; velocity = 0; autoRotateSpeed = 0; }
    function onMove(x) {
        if (!isDragging) return;
        const delta = x - lastX; lastX = x;
        angleY += delta * 0.006; velocity = delta * 0.006;
    }
    function onEnd() { isDragging = false; autoRotateSpeed = 0.0015; }

    document.addEventListener('touchstart', e => { if(e.target !== playBtn) e.preventDefault(); onStart(e.touches[0].clientX); }, {passive: false});
    document.addEventListener('touchmove', e => { if(e.target !== playBtn) e.preventDefault(); onMove(e.touches[0].clientX); }, {passive: false});
    document.addEventListener('touchend', onEnd);
    document.addEventListener('mousedown', e => onStart(e.clientX));
    document.addEventListener('mousemove', e => onMove(e.clientX));
    document.addEventListener('mouseup', onEnd);
    
    playBtn.addEventListener('click', startShow);
    playBtn.addEventListener('touchend', startShow);

    // ==========================================
    //           èƒŒæ™¯ç»„ä»¶
    // ==========================================
    class SkyStar {
        constructor() {
            this.x = Math.random() * width; this.y = Math.random() * height * 0.7;
            this.size = Math.random() * 1.5; this.alpha = Math.random();
            this.speed = Math.random() * 0.02 + 0.005; this.direction = Math.random() > 0.5 ? 1 : -1;
        }
        update() {
            this.alpha += this.speed * this.direction;
            if (this.alpha > 1) { this.alpha = 1; this.direction = -1; }
            if (this.alpha < 0.2) { this.alpha = 0.2; this.direction = 1; }
        }
        draw(ctx) {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        }
    }

    class Snow {
        constructor() { this.reset(); }
        reset() {
            this.x = (Math.random() - 0.5) * width * 2; this.y = -height; this.z = (Math.random() - 0.5) * 2000;
            this.size = Math.random() * 2 + 1; this.speed = Math.random() * 1 + 0.5;
        }
        update() {
            this.y += this.speed; if (this.y > height * 1.5) this.reset();
        }
        draw(ctx, fov, cos, sin) {
            let rx = this.x * cos - this.z * sin; let rz = this.z * cos + this.x * sin;
            let scale = fov / (fov + rz - CAMERA_Z);
            if (scale > 0) {
                let px = width/2 + rx * scale; let py = height/2 + this.y * scale;
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, scale*0.8)})`;
                ctx.beginPath(); ctx.arc(px, py, this.size * scale, 0, Math.PI*2); ctx.fill();
            }
        }
    }

    // ==========================================
    //           æ ¸å¿ƒ 3D ç²’å­ (è¿ç»­ç®—æ³•)
    // ==========================================
    class Point3D {
        constructor(type) {
            this.type = type; 
            this.reset();
        }
        
        reset() {
            this.h = Math.random();
            
            // --- æœ€ç»ˆï¼šåœ£è¯æ ‘ (Tree) ---
            const treeHeight = 900; 
            const bottomY = 450;
            
            if (this.type === 'tree') {
                this.ty = bottomY - this.h * treeHeight;
                const maxR = 300 * Math.pow(1 - this.h, 0.6);
                const r = maxR * Math.sqrt(Math.random());
                const angle = Math.random() * Math.PI * 2;
                this.tx = Math.cos(angle) * r; this.tz = Math.sin(angle) * r;
                
                const rand = Math.random();
                if (rand < 0.15) { this.style = 'light'; this.color = Math.random()>0.5 ? '#FFD700' : `hsl(${Math.random()*360},100%,70%)`; this.size = 3.5; }
                else { this.style = 'leaf'; const l = 20 + Math.random() * 30; this.color = `hsl(${115+Math.random()*20}, 75%, ${l}%)`; this.size = 2.0; }
            } else if (this.type === 'ribbon') {
                this.ty = bottomY - this.h * treeHeight;
                const maxR = 330 * (1 - this.h) + 20; const angle = this.h * 20;
                this.tx = Math.cos(angle) * maxR; this.tz = Math.sin(angle) * maxR;
                this.style = 'gold'; this.color = '#FFD700'; this.size = 2.5;
            }

            // --- åˆå§‹ï¼šåœ°é¢å…‰ç›˜ (Ground Disk) ---
            // å…³é”®ï¼šä¿å­˜åˆå§‹æåæ ‡ï¼Œç”¨äºæ— ç¼è¿‡æ¸¡
            this.groundR = 900 * Math.sqrt(Math.random());
            this.groundAngle = Math.random() * Math.PI * 2;
            
            this.sx = Math.cos(this.groundAngle) * this.groundR;
            this.sy = 900; 
            this.sz = Math.sin(this.groundAngle) * this.groundR;

            // --- ä¸­é—´æ€ï¼šé‡‘è‰²èƒ½é‡çƒ ---
            const sphereR = 250; 
            const noise = (Math.random()-0.5)*60;
            const u = Math.random(); const v = Math.random();
            const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
            
            this.spX = (sphereR+noise) * Math.sin(phi) * Math.cos(theta);
            this.spY = -500 + (sphereR+noise) * Math.sin(phi) * Math.sin(theta); 
            this.spZ = (sphereR+noise) * Math.cos(phi);

            // åˆå§‹èµ‹å€¼
            this.x = this.sx; this.y = this.sy; this.z = this.sz;
            this.driftOffset = Math.random() * 100;
        }

        update(timeline) {
            // ================= å‰§æœ¬ =================
            
            // Phase 1: åœ°é¢é™æ­¢ & å¾®åŠ¨ (0-2s)
            if (timeline < 2000) {
                // å¾®å¾®æ—‹è½¬ï¼Œä¿æŒæ»¡åœ°ç²’å­çš„æ„Ÿè§‰
                const rot = timeline * 0.0005;
                this.x = Math.cos(this.groundAngle + rot) * this.groundR;
                this.z = Math.sin(this.groundAngle + rot) * this.groundR;
                this.y = this.sy;
                this.curColor = `rgba(0, 255, 255, 0.4)`;
            }
            // Phase 2: è¿è´¯å‡ç©º (2s-8s)
            else if (timeline < 8000) {
                const animTime = timeline - 2000;
                const totalTime = 6000;
                
                // è·ç¦»ä¸­å¿ƒè¶Šè¿‘ï¼Œèµ·é£è¶Šæ—© (æ³¢æµªå¼)
                // distRatio: 0(ä¸­å¿ƒ) -> 1(è¾¹ç¼˜)
                const distRatio = this.groundR / 900;
                
                // èµ·é£å»¶è¿Ÿï¼šä¸­å¿ƒ0sï¼Œè¾¹ç¼˜2s
                const delay = distRatio * 2000; 
                
                // è®¡ç®—å½“å‰ç²’å­çš„è¿›åº¦ p
                let p = (animTime - delay) / (totalTime - 2000); 
                if (p < 0) p = 0; 
                if (p > 1) p = 1;
                
                // ç¼“åŠ¨
                const ease = p * p; // åŠ é€Ÿèµ·é£

                // --- æ ¸å¿ƒç®—æ³•ï¼šæ— ç¼æ’å€¼ ---
                // èµ·ç‚¹ï¼šå½“å‰çš„åœ°é¢æ—‹è½¬ä½ç½® (sx, sz)
                // ç»ˆç‚¹ï¼šçƒä½“ä½ç½® (spX, spZ)
                // è¿‡ç¨‹ï¼šèºæ—‹ä¸Šå‡
                
                // 1. åŠ¨æ€åŠå¾„ï¼šä» åœ°é¢åŠå¾„ -> çƒä½“åŠå¾„(è¿‘ä¼¼0)
                const currentR = this.groundR * (1 - ease); 
                
                // 2. åŠ¨æ€é«˜åº¦ï¼šåœ°é¢ -> çƒä½“é«˜åº¦
                this.y = this.sy + (this.spY - this.sy) * ease;
                
                // 3. åŠ¨æ€è§’åº¦ï¼šä¿æŒè‡ªæ—‹ + åŠ é€Ÿèºæ—‹
                const spin = ease * 15; // æ—‹è½¬15åœˆ
                const angle = this.groundAngle + spin; // æ¥ç€åœ°é¢çš„è§’åº¦è½¬
                
                // 4. æ··åˆåæ ‡
                // èºæ—‹éƒ¨åˆ† + æœ€ç»ˆçƒä½“ä½ç½®åç§»
                this.x = Math.cos(angle) * currentR + (this.spX * ease);
                this.z = Math.sin(angle) * currentR + (this.spZ * ease);
                
                this.curColor = `rgba(100, 200, 255, ${0.5 + ease * 0.5})`;
            }
            // Phase 3: é‡‘çƒæ—‹è½¬ (8s-12s)
            else if (timeline < 12000) {
                const rot = (timeline - 8000) * 0.0015;
                const cos = Math.cos(rot); const sin = Math.sin(rot);
                // ç»•çƒå¿ƒè‡ªè½¬
                this.x = this.spX * cos - this.spZ * sin;
                this.z = this.spZ * cos + this.spX * sin;
                this.y = this.spY;
                this.curColor = `rgba(255, 215, 0, 1)`;
            }
            // Phase 4: ç‘é›ªé£˜è½ (12s-22s)
            else if (timeline < 22000) {
                const p = (timeline - 12000) / 10000; 
                const ease = p < 0.5 ? 2 * p * p : -1 + (4 - 2 * p) * p;
                
                // é£˜åŠ¨
                const drift = Math.sin(timeline * 0.002 + this.driftOffset) * 40 * (1-ease);
                
                // ä» çƒä½“ -> æ ‘
                this.x = this.spX + (this.tx - this.spX) * ease + drift;
                this.z = this.spZ + (this.tz - this.spZ) * ease + drift;
                this.y = this.spY + (this.ty - this.spY) * ease;
                
                this.curColor = this.color; 
            }
            // Phase 5: ç¨³å®š (22s+)
            else {
                this.x += (this.tx - this.x) * 0.1;
                this.y += (this.ty - this.y) * 0.1;
                this.z += (this.tz - this.z) * 0.1;
                this.curColor = this.color;
            }
        }
    }

    class Text3D {
        constructor(config, angleOffset) {
            this.text = config.text; this.baseY = config.y; this.color = config.color; this.fontSize = config.size;
            this.angleOffset = angleOffset; this.radius = 420; this.type = 'text';
        }
        update(timeline) {
            this.y = this.baseY + Math.sin(timeline * 0.002 + this.angleOffset) * 15;
            this.x = Math.cos(this.angleOffset) * this.radius;
            this.z = Math.sin(this.angleOffset) * this.radius;
        }
    }

    function init() {
        renderList = [];
        skyStars = [];
        snowList = [];
        for(let i=0; i<300; i++) skyStars.push(new SkyStar());
        for(let i=0; i<150; i++) snowList.push(new Snow());
        for (let i = 0; i < 2400; i++) renderList.push(new Point3D('tree'));
        for (let i = 0; i < 200; i++) renderList.push(new Point3D('ribbon'));
        for (let i = 0; i < WISH_WORDS.length; i++) {
            const angle = (i / WISH_WORDS.length) * Math.PI * 2 + Math.PI; 
            renderList.push(new Text3D(WISH_WORDS[i], angle));
        }
    }

    function showSubtitle(text, duration) {
        subtitle.innerText = text;
        subtitle.style.opacity = 1;
        setTimeout(() => subtitle.style.opacity = 0, duration);
    }

    // ==========================================
    //           æ¸²æŸ“å¾ªç¯
    // ==========================================
    function loop() {
        if (!isPlaying) return;
        requestAnimationFrame(loop);
        
        const timeline = Date.now() - startTime;
        
        if (!isDragging) {
            if (Math.abs(velocity) > 0.0001) { angleY += velocity; velocity *= 0.95; }
            else { angleY += autoRotateSpeed; }
        }

        const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, height);
        gradient.addColorStop(0, '#1b2735'); gradient.addColorStop(1, '#090a0f');
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);

        skyStars.forEach(s => { s.update(); s.draw(ctx); });

        const fov = 800;
        const cos = Math.cos(angleY);
        const sin = Math.sin(angleY);

        snowList.forEach(s => { s.update(); s.draw(ctx, fov, cos, sin); });

        if (timeline > 2000) drawGround(timeline);
        
        renderList.forEach(obj => {
            obj.update(timeline);
            const rx = obj.x * cos - obj.z * sin;
            const rz = obj.z * cos + obj.x * sin;
            const scale = fov / (fov + (rz - CAMERA_Z));
            obj.px = width/2 + rx * scale;
            obj.py = height/2 + (obj.y - 50) * scale;
            obj.scale = scale;
            obj.depth = rz;
        });

        renderList.sort((a, b) => b.depth - a.depth);

        renderList.forEach(obj => {
            if (obj.scale <= 0) return;

            if (obj.type === 'text') {
                if (timeline > 22000) { 
                    const alpha = Math.min(1, (timeline - 22000) / 2000);
                    ctx.save(); ctx.globalAlpha = alpha;
                    ctx.font = `bold ${Math.max(10, obj.fontSize * obj.scale)}px sans-serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillStyle = obj.color; ctx.shadowBlur = 10 * obj.scale; ctx.shadowColor = obj.color;
                    ctx.fillText(obj.text, obj.px, obj.py); ctx.restore();
                }
            } else {
                ctx.beginPath();
                const size = obj.size * obj.scale;
                ctx.arc(obj.px, obj.py, size, 0, Math.PI * 2);
                ctx.fillStyle = obj.curColor;
                
                if (timeline < 8000) { 
                     ctx.shadowBlur = 4 * obj.scale; ctx.shadowColor = '#00ffff';
                } else if (timeline < 12000) { 
                     ctx.shadowBlur = 8 * obj.scale; ctx.shadowColor = '#FFD700';
                } else if (obj.style === 'light' || obj.style === 'gold') {
                    ctx.shadowBlur = 10 * obj.scale; ctx.shadowColor = obj.curColor;
                } else {
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
            }
        });

        drawTopStar(timeline, cos, sin);

        if (timeline > 22500) {
            if (Math.random() < 0.04) fireworks.push(new Firework());
            for (let i = fireworks.length - 1; i >= 0; i--) {
                let f = fireworks[i]; f.update(); f.draw();
                if (f.dead) fireworks.splice(i, 1);
            }
        }
        
        // å­—å¹•
        if (timeline > 500 && timeline < 600) showSubtitle("æ˜Ÿå…‰è‹é†’...", 1500);
        if (timeline > 2500 && timeline < 2600) showSubtitle("æ±‡èš...", 2000);
        if (timeline > 8000 && timeline < 8100) showSubtitle("å‡ç»“æˆæ„¿...", 2000);
        if (timeline > 12000 && timeline < 12100) showSubtitle("ç‘é›ªé™ä¸´...", 2000);
        if (timeline > 22000 && timeline < 22100) showSubtitle("åœ£è¯å¿«ä¹ï¼", 2000);
    }
    
    function drawGround(timeline) {
        if (timeline < 2000) return;
        const alpha = Math.min(1, (timeline - 2000) / 4000);
        const fov = 800; const radius = 500;
        ctx.save(); ctx.translate(width/2, height/2);
        
        ctx.beginPath();
        for(let i=0; i<=60; i++) {
            const angle = (i/60)*Math.PI*2;
            const x = Math.cos(angle)*radius; const z = Math.sin(angle)*radius;
            const cos = Math.cos(angleY); const sin = Math.sin(angleY);
            const rx = x*cos - z*sin; const rz = z*cos + x*sin;
            const scale = fov / (fov + (rz - CAMERA_Z));
            const px = rx * scale; const py = (500 - 50) * scale;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 * alpha})`; ctx.lineWidth = 2;
        ctx.stroke(); ctx.restore();
    }

    function drawTopStar(timeline, cos, sin) {
        if (timeline < 22000) return;
        const ty = -680; const rz = 0 * cos + 0 * sin; 
        const fov = 800; const scale = fov / (fov + (rz - CAMERA_Z));
        const px = width/2; const py = height/2 + (ty - 50) * scale;
        ctx.save(); ctx.translate(px, py); ctx.rotate(timeline * 0.002);
        ctx.beginPath(); ctx.fillStyle = "#FFD700"; 
        ctx.shadowBlur = 40; ctx.shadowColor = "#FFD700";
        for (let i = 0; i < 5; i++) {
            ctx.lineTo(Math.cos((18+i*72)*0.01745)*45*scale, -Math.sin((18+i*72)*0.01745)*45*scale);
            ctx.lineTo(Math.cos((54+i*72)*0.01745)*15*scale, -Math.sin((54+i*72)*0.01745)*15*scale);
        }
        ctx.fill(); ctx.restore(); ctx.shadowBlur = 0;
    }

    class Spark {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 5 + 2;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.alpha = 1; this.decay = Math.random() * 0.02 + 0.01;
            this.gravity = 0.08; this.drag = 0.96;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += this.gravity; this.vx *= this.drag; this.vy *= this.drag;
            this.alpha -= this.decay;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.alpha);
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 2.5, 0, Math.PI*2); ctx.fill();
        }
    }

    class Firework {
        constructor() {
            this.x = Math.random() * width; this.y = height;
            this.targetY = height * 0.15 + Math.random() * height * 0.3;
            this.vy = -12 - Math.random() * 5;
            this.color = `hsl(${Math.random()*360},100%,65%)`;
            this.state = 0; this.sparks = []; this.trail = [];
        }
        update() {
            if (this.state === 0) {
                this.y += this.vy; this.vy += 0.2;
                this.trail.push({x: this.x, y: this.y}); if(this.trail.length > 8) this.trail.shift();
                if (this.vy >= 0 || this.y < this.targetY) {
                    this.state = 1;
                    for(let i=0; i<80; i++) this.sparks.push(new Spark(this.x, this.y, this.color));
                }
            } else {
                this.sparks.forEach(s => s.update());
                this.sparks = this.sparks.filter(s => s.alpha > 0);
                if (this.sparks.length === 0) this.dead = true;
            }
        }
        draw() {
            ctx.globalCompositeOperation = 'lighter';
            if (this.state === 0) {
                if(this.trail.length > 1) {
                    ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for(let i=1; i<this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    ctx.strokeStyle = `rgba(255,255,255,0.4)`; ctx.stroke();
                }
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
            } else {
                this.sparks.forEach(s => s.draw());
            }
            ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
        }
    }

    function startShow() {
        if (isPlaying) return;
        isPlaying = true;
        document.getElementById('bgm').play().catch(()=>{});
        startScreen.style.opacity = 0;
        setTimeout(() => startScreen.style.display = 'none', 1000);
        init();
        startTime = Date.now();
        loop();
    }
</script>
</body>
</html>




