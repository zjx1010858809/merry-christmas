<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas</title>
    <style>
        /* é¡µé¢åŸºç¡€è®¾å®š */
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #050505; height: 100%; font-family: "Microsoft YaHei", sans-serif; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* å¯åŠ¨ç•Œé¢ (å¸¦æ¯›ç»ç’ƒ) */
        #start-screen {
            pointer-events: auto; /* å…è®¸ç‚¹å‡» */
            background: rgba(0,0,0,0.92);
            width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
            position: absolute; top: 0; left: 0; z-index: 200;
        }

        /* ä¿®å¤åçš„æŒ‰é’®æ ·å¼ï¼Œå¢å¤§ç‚¹å‡»åŒºåŸŸ */
        .btn-play {
            padding: 20px 60px; font-size: 1.5rem; color: #fff;
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            border: 2px solid #fff; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 40px rgba(0, 210, 255, 0.8);
            font-weight: bold; letter-spacing: 4px;
            animation: pulse 1.5s infinite;
            z-index: 201; /* ä¿è¯æœ€ä¸Šå±‚ */
            touch-action: manipulation; /* ä¼˜åŒ–è§¦æ§å“åº” */
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); box-shadow: 0 0 60px rgba(0, 210, 255, 1); } 100% { transform: scale(1); } }

        .hint { color: #888; margin-top: 30px; font-size: 14px; animation: blink 3s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* å­—å¹• */
        #subtitle {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: #fff; font-size: 1.2rem; letter-spacing: 3px;
            text-shadow: 0 0 10px #fff; opacity: 0; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="start-screen">
        <button id="playBtn" class="btn-play">ğŸ ç‚¹äº®æ˜Ÿæ²³</button>
        <div class="hint">âœ¨ å»ºè®®å…¨å±è§‚çœ‹ ä½©æˆ´è€³æœº âœ¨</div>
    </div>
    <div id="subtitle"></div>
</div>

<canvas id="canvas"></canvas>
<audio id="bgm" loop>
    <source src="https://music.163.com/song/media/outer/url?id=1901371647.mp3" type="audio/mpeg">
</audio>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const subtitle = document.getElementById('subtitle');
    const startScreen = document.getElementById('start-screen');
    const playBtn = document.getElementById('playBtn');
    
    let width, height;
    let renderList = [];
    let fireworks = [];
    
    let isPlaying = false;
    let startTime = 0;
    
    // --- æ‘„åƒæœºä¸äº¤äº’ ---
    let cameraZ = -900;
    let angleY = 0;
    
    let isDragging = false;
    let lastX = 0;
    let velocity = 0;
    
    // 3D ç¯ç»•æ–‡å­—é…ç½®
    const WISH_WORDS = [
        { text: "è€å©†", y: -650, color: "#FF3366", size: 50 },
        { text: "åœ£è¯å¿«ä¹", y: -450, color: "#FFD700", size: 40 },
        { text: "å¹³å®‰", y: -250, color: "#00FFFF", size: 35 },
        { text: "å–œä¹", y: -50, color: "#00FF7F", size: 35 },
        { text: "æ°¸è¿œçˆ±ä½ ", y: 150, color: "#FF69B4", size: 40 }
    ];

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    //           äº¤äº’é€»è¾‘ (å·²ä¿®å¤ç‚¹å‡»é—®é¢˜)
    // ==========================================
    function onStart(x) { isDragging = true; lastX = x; velocity = 0; }
    function onMove(x) {
        if (!isDragging) return;
        const delta = x - lastX;
        lastX = x;
        angleY += delta * 0.005;
        velocity = delta * 0.005;
    }
    function onEnd() { isDragging = false; }

    // æ ¸å¿ƒä¿®å¤ï¼šåªæœ‰å½“ç‚¹å‡»çš„ä¸æ˜¯æŒ‰é’®æ—¶ï¼Œæ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆé˜²æ­¢é¡µé¢æ»šåŠ¨ï¼‰
    document.addEventListener('touchstart', e => { 
        if(e.target !== playBtn) e.preventDefault(); 
        onStart(e.touches[0].clientX); 
    }, {passive: false});

    document.addEventListener('touchmove', e => { 
        if(e.target !== playBtn) e.preventDefault();
        onMove(e.touches[0].clientX); 
    }, {passive: false});

    document.addEventListener('touchend', onEnd);
    
    // é¼ æ ‡å…¼å®¹
    document.addEventListener('mousedown', e => onStart(e.clientX));
    document.addEventListener('mousemove', e => onMove(e.clientX));
    document.addEventListener('mouseup', onEnd);

    // ç»‘å®šæŒ‰é’®ç‚¹å‡»
    playBtn.addEventListener('click', startShow);
    playBtn.addEventListener('touchend', startShow); // å¤‡ç”¨

    // ==========================================
    //           3D å¯¹è±¡ç±»
    // ==========================================
    class Point3D {
        constructor(type) {
            this.type = type; 
            this.reset();
        }
        
        reset() {
            this.h = Math.random();
            const treeH = 1200;
            const bottomY = 500;
            
            if (this.type === 'tree') {
                this.ty = bottomY - this.h * treeH;
                const maxR = 400 * Math.pow(1 - this.h, 0.7);
                const r = maxR * Math.sqrt(Math.random());
                const angle = Math.random() * Math.PI * 2;
                
                this.tx = Math.cos(angle) * r;
                this.tz = Math.sin(angle) * r;
                
                const rand = Math.random();
                if (rand < 0.1) { this.style = 'star'; this.color = '#fff'; this.size = 2.5; }
                else if (rand < 0.25) { this.style = 'light'; this.color = Math.random()>0.5 ? '#FFD700' : `hsl(${Math.random()*360},100%,60%)`; this.size = 3.5; }
                else { this.style = 'leaf'; this.color = `hsl(${120+Math.random()*40}, 80%, ${20+this.h*30}%)`; this.size = 2; }
                
            } else if (this.type === 'ribbon') {
                this.ty = bottomY - this.h * treeH;
                const maxR = 420 * (1 - this.h) + 30;
                const angle = this.h * 25;
                this.tx = Math.cos(angle) * maxR;
                this.tz = Math.sin(angle) * maxR;
                this.style = 'gold'; this.color = '#FFD700'; this.size = 2.8;
            }

            // åˆå§‹åæ ‡è®¾ä¸º0ï¼Œupdateé‡Œè®¡ç®—èºæ—‹è½¨è¿¹
            this.x = 0; this.y = 0; this.z = 0;
            this.wobble = Math.random() * 100;
        }

        update(timeline) {
            // èºæ—‹æ±‡èš (0-8ç§’)
            if (timeline < 8000) {
                const p = timeline / 8000;
                const ease = p * p * (3 - 2 * p);
                
                const spiralR = 1200 * (1 - ease) + 50;
                const spin = (1 - ease) * 15;
                const angle = spin + this.h * 10;
                
                this.x = Math.cos(angle) * spiralR;
                this.z = Math.sin(angle) * spiralR;
                this.y = 1000 + (this.ty - 1000) * ease;
                this.curColor = `rgba(0, 255, 255, 0.8)`;
            } else {
                this.x += (this.tx - this.x) * 0.1;
                this.y += (this.ty - this.y) * 0.1;
                this.z += (this.tz - this.z) * 0.1;
                this.curColor = this.color;
            }
        }
    }

    class Text3D {
        constructor(config, angleOffset) {
            this.text = config.text;
            this.baseY = config.y;
            this.color = config.color;
            this.fontSize = config.size;
            this.angleOffset = angleOffset;
            this.radius = 550;
            this.type = 'text';
        }

        update(timeline) {
            this.y = this.baseY + Math.sin(timeline * 0.002 + this.angleOffset) * 20;
            this.x = Math.cos(this.angleOffset) * this.radius;
            this.z = Math.sin(this.angleOffset) * this.radius;
        }
    }

    function init() {
        renderList = [];
        for (let i = 0; i < 3500; i++) renderList.push(new Point3D('tree'));
        for (let i = 0; i < 400; i++) renderList.push(new Point3D('ribbon'));
        const count = WISH_WORDS.length;
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + Math.PI; 
            renderList.push(new Text3D(WISH_WORDS[i], angle));
        }
    }

    function showSubtitle(text, duration) {
        subtitle.innerText = text;
        subtitle.style.opacity = 1;
        setTimeout(() => subtitle.style.opacity = 0, duration);
    }

    function loop() {
        if (!isPlaying) return;
        requestAnimationFrame(loop);
        
        const timeline = Date.now() - startTime;
        
        if (!isDragging) {
            if (Math.abs(velocity) > 0.0001) {
                angleY += velocity;
                velocity *= 0.95;
            } else {
                angleY += 0.001;
            }
        }

        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);

        if (timeline > 2000) drawGround(timeline);

        const fov = 800;
        const cos = Math.cos(angleY);
        const sin = Math.sin(angleY);
        
        renderList.forEach(obj => {
            obj.update(timeline);
            const rx = obj.x * cos - obj.z * sin;
            const rz = obj.z * cos + obj.x * sin;
            const scale = fov / (fov + (rz - cameraZ));
            obj.px = width/2 + rx * scale;
            obj.py = height/2 + (obj.y - 50) * scale;
            obj.scale = scale;
            obj.depth = rz;
        });

        renderList.sort((a, b) => b.depth - a.depth);

        ctx.globalCompositeOperation = 'lighter';
        
        renderList.forEach(obj => {
            if (obj.scale <= 0) return;

            if (obj.type === 'text') {
                if (timeline > 8000) {
                    const alpha = Math.min(1, (timeline - 8000) / 2000);
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    const fontSize = Math.max(10, obj.fontSize * obj.scale);
                    ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 15 * obj.scale; ctx.shadowColor = obj.color;
                    ctx.fillStyle = obj.color;
                    ctx.fillText(obj.text, obj.px, obj.py);
                    ctx.restore();
                }
            } else {
                let alpha = 1;
                if (timeline > 8000 && (obj.style === 'light' || obj.style === 'gold')) {
                     alpha = 0.5 + 0.5 * Math.sin(timeline * 0.005 + obj.wobble);
                }
                
                ctx.beginPath();
                const size = obj.size * obj.scale;
                ctx.arc(obj.px, obj.py, size, 0, Math.PI * 2);
                ctx.fillStyle = obj.curColor;
                ctx.globalAlpha = alpha;
                
                if (timeline > 8000 && (obj.style === 'light' || obj.style === 'gold')) {
                    ctx.shadowBlur = 10 * obj.scale; ctx.shadowColor = obj.curColor;
                } else if (timeline < 8000) {
                    ctx.shadowBlur = 5 * obj.scale; ctx.shadowColor = obj.curColor;
                } else {
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
            }
        });
        
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        drawTopStar(timeline, cos, sin);

        if (timeline > 9000) {
            if (Math.random() < 0.05) fireworks.push(new Firework());
            fireworks.forEach((f, i) => { f.update(); f.draw(); if(f.dead) fireworks.splice(i,1); });
        }
        
        if (timeline > 500 && timeline < 600) showSubtitle("æ˜Ÿæ²³æ±‡èš...", 2000);
        if (timeline > 4000 && timeline < 4100) showSubtitle("åªä¸ºä½ ä¸€äºº...", 2000);
        if (timeline > 8000 && timeline < 8100) showSubtitle("åœ£è¯å¿«ä¹ï¼", 2000);
    }
    
    function drawGround(timeline) {
        if (timeline < 1000) return;
        const alpha = Math.min(1, (timeline - 1000) / 3000);
        const fov = 800; const radius = 500;
        ctx.save(); ctx.translate(width/2, height/2);
        ctx.beginPath();
        for(let i=0; i<=60; i++) {
            const angle = (i/60)*Math.PI*2;
            const x = Math.cos(angle)*radius; const z = Math.sin(angle)*radius;
            const cos = Math.cos(angleY); const sin = Math.sin(angleY);
            const rx = x*cos - z*sin; const rz = z*cos + x*sin;
            const scale = fov / (fov + (rz - cameraZ));
            const px = rx * scale; const py = (500 - 100) * scale;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 * alpha})`; ctx.lineWidth = 3;
        ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.stroke(); ctx.restore();
    }

    function drawTopStar(timeline, cos, sin) {
        if (timeline < 8000) return;
        const ty = -750; const rz = 0 * cos + 0 * sin; const fov = 800;
        const scale = fov / (fov + (rz - cameraZ));
        const px = width/2; const py = height/2 + (ty - 100) * scale;
        ctx.save(); ctx.translate(px, py); ctx.rotate(timeline * 0.002);
        ctx.globalCompositeOperation = 'lighter'; ctx.beginPath();
        ctx.fillStyle = "#FFD700"; ctx.shadowBlur = 50; ctx.shadowColor = "#FFD700";
        for (let i = 0; i < 8; i++) {
            ctx.lineTo(Math.cos(i*Math.PI/4)*50*scale, -Math.sin(i*Math.PI/4)*50*scale);
            ctx.lineTo(Math.cos((i+0.5)*Math.PI/4)*15*scale, -Math.sin((i+0.5)*Math.PI/4)*15*scale);
        }
        ctx.fill(); ctx.restore(); ctx.globalCompositeOperation = 'source-over';
    }

    class Firework {
        constructor() {
            this.x = Math.random() * width; this.y = height;
            this.ty = height * 0.2 + Math.random() * height * 0.3;
            this.vy = -12 - Math.random() * 5;
            this.color = `hsl(${Math.random()*360},100%,70%)`;
            this.state = 0; this.pt = []; this.trail = [];
        }
        update() {
            if (this.state === 0) {
                this.y += this.vy; this.vy += 0.2;
                this.trail.push({x:this.x, y:this.y}); if(this.trail.length>8) this.trail.shift();
                if (this.vy >= 0 || this.y < this.ty) {
                    this.state = 1;
                    for (let i=0; i<60; i++) {
                        const a = Math.random()*Math.PI*2; const s = Math.random()*5+1;
                        this.pt.push({x:this.x, y:this.y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, alpha:1});
                    }
                }
            } else {
                this.pt.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.alpha-=0.02; });
                if (this.pt[0] && this.pt[0].alpha <= 0) this.dead = true;
            }
        }
        draw() {
            ctx.globalCompositeOperation = 'lighter';
            if (this.state === 0) {
                ctx.beginPath(); 
                if(this.trail.length>1) {
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for(let i=1;i<this.trail.length;i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    ctx.strokeStyle=`rgba(255,255,255,0.3)`; ctx.stroke();
                }
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
            } else {
                this.pt.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
                    ctx.fillStyle = this.color; ctx.globalAlpha = p.alpha; ctx.fill();
                });
            }
            ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
        }
    }

    function startShow() {
        if (isPlaying) return;
        isPlaying = true; // é˜²æ­¢é‡å¤ç‚¹å‡»
        
        // æ’­æ”¾éŸ³ä¹
        document.getElementById('bgm').play().catch(()=>{});
        
        // éšè—UI
        startScreen.style.opacity = 0;
        setTimeout(() => startScreen.style.display = 'none', 1000);
        
        // å¯åŠ¨æ¸²æŸ“
        init();
        startTime = Date.now();
        loop();
    }
</script>
</body>
</html>
